

<!DOCTYPE html>
<html class="writer-html5" lang="python" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>kalmus.utils.artist &mdash; KALMUS 1.3.6 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> KALMUS
          

          
          </a>

          
            
            
              <div class="version">
                1.3.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kalmus.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../update_log.html">KALMUS Update Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acknowledge.html">Acknowledgement</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">KALMUS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>kalmus.utils.artist</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for kalmus.utils.artist</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Utility Artist &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">watershed</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">remove_small_objects</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="k">import</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sobel</span>
<span class="kn">from</span> <span class="nn">skimage.future</span> <span class="k">import</span> <span class="n">graph</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>


<div class="viewcode-block" id="compute_dominant_color"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_dominant_color">[docs]</a><span class="k">def</span> <span class="nf">compute_dominant_color</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">threshold_error</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the dominant color of an input image using the kmeans clustering. The centers of the</span>
<span class="sd">    clusters are the dominant colors of the input image</span>

<span class="sd">    :param image: input image. Either a multi-channel color image or a grayscale image (2D image) \</span>
<span class="sd">    Expected shape of image is height x width x (channels)</span>
<span class="sd">    :param n_clusters: number of clusters</span>
<span class="sd">    :param max_iter: maximum iterations before terminating kmeans clustering</span>
<span class="sd">    :param threshold_error: threshold error for terminating kmeans clustering. kmean clustering terminate \</span>
<span class="sd">    when the errors between the current computed and previous computed cluster center is under this \</span>
<span class="sd">    threshold</span>
<span class="sd">    :param attempts: Number of attempts to rerun the Kmeans clustering with different initial cluster \</span>
<span class="sd">    centers. Since kmeans clustering randomly choose n number of cluster in its initialization process.</span>
<span class="sd">    :return: An array of n cluster centers and an array of relative size (in percentage) of the clusters. \</span>
<span class="sd">    Expected output shape: n_clusters x channels (cluster centers), n_clusters (relative size in percentage) \</span>
<span class="sd">    E.g. for an input color image with 3 channels and n_clusters = 3  Output can be [[255, 255, 255], \</span>
<span class="sd">    [126, 75, 198], [186, 145, 122]], [0.4, 0.5, 0.1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;The input must be a 2 dimensional image&quot;</span>
    <span class="c1"># Flatten the image</span>
    <span class="c1"># If the image is in grayscale</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">flatten_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="c1"># make sure the dtype of the flatten image is np.float32</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">threshold_error</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">centers</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">attempts</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">KMEANS_RANDOM_CENTERS</span><span class="p">)</span>

    <span class="n">percent_of_dominance</span> <span class="o">=</span> <span class="n">compute_percents_of_labels</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">centers</span><span class="p">,</span> <span class="n">percent_of_dominance</span></div>


<div class="viewcode-block" id="flatten_image"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.flatten_image">[docs]</a><span class="k">def</span> <span class="nf">flatten_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat the input 2D image into an 1D image while preserve the channels of the input image</span>
<span class="sd">    with shape==[height x width, channels]</span>

<span class="sd">    :param image: Input 2D image (either multi-channel color image or greyscale image)</span>
<span class="sd">    :return: The flatten 1D image. shape==(height x width, channels)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;The input image must be a 2 Dimensional image&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="compute_percents_of_labels"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_percents_of_labels">[docs]</a><span class="k">def</span> <span class="nf">compute_percents_of_labels</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the ratio/percentage size of the labels in an labeled image</span>

<span class="sd">    :param label: the labeled 2D image</span>
<span class="sd">    :return: An array of relative size of the labels in the image. Indices of the sizes in the array \</span>
<span class="sd">    is corresponding to the labels in the labeled image. E.g. output [0.2, 0.5, 0.3] means label 0&#39;s size \</span>
<span class="sd">    is 0.2 of the labeled image, label 1&#39; size is 0.5 of the labeled image, and label 2&#39;s size is 0.3 of \</span>
<span class="sd">    the labeled image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the bins of the histogram. Since the last bin of the histogram is [label, label+1]</span>
    <span class="c1"># We add 1 to the number of different labels in the labeled image when generating bins</span>
    <span class="n">num_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Histogramize the label image and get the frequency array percent_of_dominance</span>
    <span class="p">(</span><span class="n">percent_of_dominance</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_labels</span><span class="p">)</span>
    <span class="c1"># Convert the dtype of frequency array to float</span>
    <span class="n">percent_of_dominance</span> <span class="o">=</span> <span class="n">percent_of_dominance</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="c1"># Normalized by the sum of frequencies (number of pixels in the labeled image)</span>
    <span class="n">percent_of_dominance</span> <span class="o">/=</span> <span class="n">percent_of_dominance</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">percent_of_dominance</span></div>


<div class="viewcode-block" id="compute_mode_color"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_mode_color">[docs]</a><span class="k">def</span> <span class="nf">compute_mode_color</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute the mode color of an input image</span>

<span class="sd">    :param image: either a multi-channel color image or a single channel greyscale image \</span>
<span class="sd">    Expected shape of image: height x width x (channels)</span>
<span class="sd">    :param bin_size: Histogramize the input image. Color/intensity of each pixel in the \</span>
<span class="sd">    image will be accumulate in the bins with size==bin_size. The output mode color/intensity \</span>
<span class="sd">    is always an integer multiple of the bin_size.</span>
<span class="sd">    :return: The mode color of the image (modes of the channels), shape=channels, and counts of the \</span>
<span class="sd">    mode colors happened in the input image, shape==channels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">flatten_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">//</span> <span class="n">bin_size</span>
    <span class="n">mode_color</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">mode_color</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">),</span> <span class="n">counts</span></div>


<div class="viewcode-block" id="compute_mean_color"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_mean_color">[docs]</a><span class="k">def</span> <span class="nf">compute_mean_color</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the average/mean color of the input multi-channel image or greyscale image.</span>

<span class="sd">    :param image: input image. Either a multi-channel color image or a single channel greyscale image</span>
<span class="sd">    :return: The average color of the image (averaged across the channels). shape==channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">flatten_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">avg_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avg_color</span></div>


<div class="viewcode-block" id="compute_median_color"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_median_color">[docs]</a><span class="k">def</span> <span class="nf">compute_median_color</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median color of the input multi-channel color image or a single channel greyscale image.</span>

<span class="sd">    :param image: input image. Either a multi-channel color image or a single channel greyscale image</span>
<span class="sd">    :return: The median color of the image (median values of channels), shape==channels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">flatten_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">median_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">median_color</span></div>


<div class="viewcode-block" id="compute_brightest_color_and_brightness"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.compute_brightest_color_and_brightness">[docs]</a><span class="k">def</span> <span class="nf">compute_brightest_color_and_brightness</span><span class="p">(</span><span class="n">grey_image</span><span class="p">,</span> <span class="n">color_image</span><span class="p">,</span> <span class="n">return_min</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">gaussian_blur</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">blur_radius</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the brightest pixel in an image and return the color and brightness at that pixel</span>

<span class="sd">    :param blur_radius: The radius of the gaussian filter</span>
<span class="sd">    :param gaussian_blur: Whether to apply a gaussian filter before finding the brightest point the grey image</span>
<span class="sd">    :param grey_image: The greyscale image. single channel 2D image. Expected shape==(row/height, col/width)</span>
<span class="sd">    :param color_image: The corresponding color image. Expected shape==(row/height, col/width, channels)</span>
<span class="sd">    :param return_min: If true return the color and brightness of the darkest pixel as well</span>
<span class="sd">    :return: The color and brightness of the brightest pixel (, color and brightness of the darkest pixel)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gaussian_blur</span><span class="p">:</span>
        <span class="n">grey_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">grey_image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">(</span><span class="n">blur_radius</span><span class="p">,</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">min_brightness</span><span class="p">,</span> <span class="n">max_brightness</span><span class="p">,</span> <span class="n">min_loc</span><span class="p">,</span> <span class="n">max_loc</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minMaxLoc</span><span class="p">(</span><span class="n">grey_image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_min</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">color_image</span><span class="p">[</span><span class="n">max_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">max_brightness</span><span class="p">,</span> <span class="n">max_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> \
               <span class="n">color_image</span><span class="p">[</span><span class="n">min_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">min_brightness</span><span class="p">,</span> <span class="n">min_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">color_image</span><span class="p">[</span><span class="n">max_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">max_brightness</span><span class="p">,</span> <span class="n">max_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="find_bright_spots"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.find_bright_spots">[docs]</a><span class="k">def</span> <span class="nf">find_bright_spots</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">blur_radius</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">amount_of_bright_parts</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">return_all_pos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices location of the top-k brightest spots in an color image.</span>

<span class="sd">    :param image: input image. Must be an mutli-channel RGB color image</span>
<span class="sd">    :param n_clusters: expected number of clusters/brightest spots in the input image</span>
<span class="sd">    :param blur_radius: radius of the Gaussian blur kernel that used to smooth the image</span>
<span class="sd">    :param amount_of_bright_parts: amount of bright parts in an image. Used to find the lower bound for \</span>
<span class="sd">    distinguishing the bright and non-bright part of the input image. Range of amount_of_bright_parts is \</span>
<span class="sd">    in [0, 1] (all non-bright -&gt; all bright)</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">amount_of_bright_parts</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">amount_of_bright_parts</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Range of the sample ration is in [0, 1]&quot;</span>
    <span class="k">assert</span> <span class="n">n_clusters</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;The number of bright spots must be larger or equal to 1&quot;</span>

    <span class="n">amount_of_bright_parts</span> <span class="o">=</span> <span class="n">amount_of_bright_parts</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="c1"># Convert BRG to Greyscale</span>
    <span class="n">grayscale_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>

    <span class="c1"># Blur the image with radius = blurRadius</span>
    <span class="n">blurred_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">grayscale_img</span><span class="p">,</span> <span class="p">(</span><span class="n">blur_radius</span><span class="p">,</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute the lower bound threshold</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">blurred_img</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">amount_of_bright_parts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Threshold the imgae by setting any pixel with value larger than lower bound to 255</span>
    <span class="n">threshed_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">blurred_img</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Purifiy the edges of the brightest spots.</span>
    <span class="n">threshed_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">erode</span><span class="p">(</span><span class="n">threshed_img</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">threshed_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="n">threshed_img</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Get the location of all white pixel in binary threshold image</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">threshed_img</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># convert to np.float32</span>
        <span class="n">locs_above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

        <span class="c1"># define criteria and apply kmeans()</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">center</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">locs_above_threshold</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">KMEANS_RANDOM_CENTERS</span><span class="p">)</span>

        <span class="c1"># Compute the percentage of each clusters in the image.</span>
        <span class="n">percent_of_dominance</span> <span class="o">=</span> <span class="n">compute_percents_of_labels</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_all_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">label</span><span class="p">,</span> <span class="n">locs_above_threshold</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">percent_of_dominance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">center</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">percent_of_dominance</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># Catch exception return negative array.</span>
        <span class="k">if</span> <span class="n">return_all_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span></div>


<div class="viewcode-block" id="random_sample_pixels"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.random_sample_pixels">[docs]</a><span class="k">def</span> <span class="nf">random_sample_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sample_ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;row-col&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly sample an amount of pixels from an image based on the given sampled ratio.</span>
<span class="sd">    Two sampling mode are available.</span>
<span class="sd">    row-col: sampling first across the row and then across the column on each sampled row</span>
<span class="sd">    The output sampled image is still 2D and keep same aspect ratio as the input image, which</span>
<span class="sd">    can be used to visualize the sampling effect on the image.</span>
<span class="sd">    flat: sampling across the flat input image. The shape and aspect ratio of the input image</span>
<span class="sd">    are not preserved due to the flatten process, but it sample the pixels much faster than</span>
<span class="sd">    &#39;row-col&#39; mode. The distribution of the sampling result is similar to that from the &#39;row-col&#39;</span>

<span class="sd">    :param img: Input 2D image. Either a multi-channel color image or a single channel greyscale image \</span>
<span class="sd">    Expected shape==height x width x (channels)</span>
<span class="sd">    :param sample_ratio: The amount of pixels sampled from the image. in range [0, 1]</span>
<span class="sd">    :param mode: two sampling mode are available. \</span>
<span class="sd">    1) &#39;row-col&#39; sampling mode 2) &#39;flat&#39; sampling mode</span>
<span class="sd">    :return: If mode=&quot;flat&quot;, return the resampled array of pixels (1-d flat array of data points) \</span>
<span class="sd">             If mode=&quot;row-col&quot;, return the resampled image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sample_ratio</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;The sample ratio is in the range of [0, 1]&quot;</span>
    <span class="k">if</span> <span class="n">sample_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span>
    <span class="k">elif</span> <span class="n">sample_ratio</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;row-col&quot;</span><span class="p">:</span>
        <span class="c1"># To keep the aspect ratio of the input image, sample equal ratio on the columns and rows</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_ratio</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Number of row to sample</span>
        <span class="n">row_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
        <span class="c1"># Number of column to sample</span>
        <span class="n">col_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
        <span class="c1"># Sample the row first</span>
        <span class="n">random_row_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">row_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">random_row</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">random_row_indices</span><span class="p">]</span>
        <span class="n">random_pixels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Then, in each row, sampled a number of pixels/columns</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">random_row</span><span class="p">:</span>
            <span class="n">random_col_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">col_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">random_pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">random_col_indices</span><span class="p">])</span>
        <span class="n">random_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_pixels</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span>
        <span class="c1"># Flatten the image</span>
        <span class="n">flat_img</span> <span class="o">=</span> <span class="n">flatten_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="c1"># Generate the possible indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">flat_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Generate the sampled indices</span>
        <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_ratio</span> <span class="o">*</span> <span class="n">flat_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Sampled the flat image using the sampled indices</span>
        <span class="n">random_pixels</span> <span class="o">=</span> <span class="n">flat_img</span><span class="p">[</span><span class="n">sampled_indices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If none of two modes is specified</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid sampling mode. Two sampling options are &#39;row-col&#39; and &#39;flat&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_pixels</span><span class="p">)</span></div>


<div class="viewcode-block" id="watershed_segmentation"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.watershed_segmentation">[docs]</a><span class="k">def</span> <span class="nf">watershed_segmentation</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minimum_segment_size</span><span class="o">=</span><span class="mf">0.0004</span><span class="p">,</span> <span class="n">base_ratio</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">denoise_disk_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                           <span class="n">gradiant_disk_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                           <span class="n">marker_disk_size</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the connected regions in an image.</span>
<span class="sd">    Use edge detection approach with watershed algorithm.</span>
<span class="sd">    adjust the critical gradient (edge gradient) with the distribution of the input image&#39;s</span>
<span class="sd">    intensity gradient .</span>

<span class="sd">    :param grey_image: The input image for region segmentation</span>
<span class="sd">    :param minimum_segment_size: The minimum size of the segments in the segmented image in percentage \</span>
<span class="sd">    (size is the relative ratio of the image) The segmented regions smaller than the minimum size will be merged \</span>
<span class="sd">    to its neighboring larger segmented components</span>
<span class="sd">    :param base_ratio: Amount of regions at least in the image. The image in watershed transformation is \</span>
<span class="sd">    differentiated into two parts regions + boundaries. The base ratio is the ratio between the least amount of \</span>
<span class="sd">    pixels that are regions and the total amount of pixels in the image.</span>
<span class="sd">    :param denoise_disk_size: the kernel size of the denoise median filter</span>
<span class="sd">    :param gradiant_disk_size: the kernel size of the gradient filter that is used for determining the amount of \</span>
<span class="sd">    boundaries</span>
<span class="sd">    :param marker_disk_size: the kernel size of the gradient filter that is used for generating transformation \</span>
<span class="sd">    marker</span>
<span class="sd">    :return: the segmented image, where shape==input_image.shape. and regions are labeled from 0 to n-1, where \</span>
<span class="sd">    n is the number of regions in the labeled image. Functions also return the greyscale image corresponding to \</span>
<span class="sd">    the original image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minimum_segment_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;The minimum size of the segments (in percentage ratio) is in range [0, 1)&quot;</span>
    <span class="c1"># Gray Scale image</span>
    <span class="n">grey_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>

    <span class="c1"># denoise image</span>
    <span class="n">denoised</span> <span class="o">=</span> <span class="n">rank</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">grey_image</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="n">denoise_disk_size</span><span class="p">))</span>

    <span class="n">num_of_pixels</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># local gradient</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">rank</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">denoised</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="n">gradiant_disk_size</span><span class="p">))</span>
    <span class="n">critical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Use std to adjust the ratio of the regions in the image</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
    <span class="c1"># A high std of the image&#39;s intensity gradient means the intensities of image are changed more rapidly</span>
    <span class="c1"># and frequently, so there are more boundaries but less regions. A low std of the image&#39;s intensity</span>
    <span class="c1"># gradients means the changes across the image are more smooth. Such coherence indicate a larger ratio</span>
    <span class="c1"># of regions in the image</span>
    <span class="c1"># Divide adjust ratio by the std of the gradient distribution</span>
    <span class="n">adjust_ratio</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="mi">25</span> <span class="o">/</span> <span class="p">(</span><span class="n">criteria</span> <span class="o">+</span> <span class="mf">1e6</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">adjust_ratio</span> <span class="o">&gt;</span> <span class="mf">0.45</span><span class="p">):</span>
        <span class="n">adjust_ratio</span> <span class="o">=</span> <span class="mf">0.45</span>
    <span class="c1"># Assume at least 50% of an image is the content (at most 50% of an image</span>
    <span class="c1"># is edge), and at most 95% of an image is the content (at least 5% of an</span>
    <span class="c1"># image is edge)</span>
    <span class="c1"># Critical is the critical threshold of intensity gradient that separate the regions and boundaries</span>
    <span class="c1"># Pixels with gradients larger than critical are considered as boundaries</span>
    <span class="c1"># Pixels with gradients smaller than critical are considered as regions</span>
    <span class="n">critical</span> <span class="o">=</span> <span class="n">critical</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">num_of_pixels</span> <span class="o">*</span> <span class="p">(</span><span class="n">base_ratio</span> <span class="o">+</span> <span class="n">adjust_ratio</span><span class="p">))]</span>

    <span class="c1"># Minimum size of a segment</span>
    <span class="c1"># Segments under the minimum size will be joined into larger segments</span>
    <span class="n">segment_min_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_of_pixels</span> <span class="o">*</span> <span class="n">minimum_segment_size</span><span class="p">)</span>
    <span class="c1"># find continuous region which marked by gradient lower than critical gradient</span>
    <span class="n">markers</span> <span class="o">=</span> <span class="n">rank</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">denoised</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="n">marker_disk_size</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">critical</span>
    <span class="n">markers</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">markers</span><span class="p">,</span> <span class="n">segment_min_size</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># process the watershed transformation</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>

    <span class="c1"># Return the labeled image and the corresponding greyscale image</span>
    <span class="k">return</span> <span class="n">regions</span><span class="p">,</span> <span class="n">grey_image</span></div>


<div class="viewcode-block" id="get_rag"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.get_rag">[docs]</a><span class="k">def</span> <span class="nf">get_rag</span><span class="p">(</span><span class="n">gray_image</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the region adjacency graph using the labeled image and corresponding the edge map generated by</span>
<span class="sd">    greyscale image with sobel filter</span>

<span class="sd">    :param gray_image: The greyscale image corresponding to the labeled image</span>
<span class="sd">    :param labels: a labeled segmented image, where the pixels in the image are labeled with index of the \</span>
<span class="sd">    segmented regions.</span>
<span class="sd">    :return: The region adjacency graph in dictionary \</span>
<span class="sd">    see https://scikit-image.org/docs/stable/auto_examples/segmentation/plot_rag_boundary.html for more \</span>
<span class="sd">    references</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get rag of the labeled image</span>
    <span class="n">edge_map</span> <span class="o">=</span> <span class="n">sobel</span><span class="p">(</span><span class="n">gray_image</span><span class="p">)</span>
    <span class="n">rag</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">rag_boundary</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">edge_map</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rag</span></div>


<div class="viewcode-block" id="rag_to_matrix"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.rag_to_matrix">[docs]</a><span class="k">def</span> <span class="nf">rag_to_matrix</span><span class="p">(</span><span class="n">rag</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transfer the region adjacency dictionary to a more accessible region adjacency matrix</span>
<span class="sd">    where in the matrix, 1 means the region of corresponding column index is adjacent to the</span>
<span class="sd">    region of corresponding row index/</span>
<span class="sd">    e.g.</span>
<span class="sd">    0,1</span>
<span class="sd">    1,0 means region 0 and region 1 are adjacent</span>

<span class="sd">    :param rag: region adjacency dictionary</span>
<span class="sd">    :param num_regions: number of regions in the region adjacency graph</span>
<span class="sd">    :return: An binary adjacency matrix with shape==num_regions x num_regions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_regions</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_regions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">rag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
        <span class="n">adj_list</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">:</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">keys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">matrix</span></div>


<div class="viewcode-block" id="color_of_regions"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.color_of_regions">[docs]</a><span class="k">def</span> <span class="nf">color_of_regions</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">original_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average color and brightest color of the regions and record</span>
<span class="sd">    the relative size of the regions as a ratio with respect to the size</span>
<span class="sd">    of whole image.</span>

<span class="sd">    :param labels: The labeled image. Expected shape==height x width. Integer labels</span>
<span class="sd">    :param original_image: The original color image corresponding to the label image</span>
<span class="sd">    :return: A list of average color of the regions, a list of brightest color of the regions, and \</span>
<span class="sd">    a list of sizes of the regions. The order of the regions in list is the same as they are in \</span>
<span class="sd">    labeled image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Average Color of the region</span>
    <span class="n">avg_colors_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Brightest Color of the region</span>
    <span class="n">brightest_colors_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Sizes of the regions in the image.</span>
    <span class="n">region_sizes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Size of the whole image in pixels</span>
    <span class="n">num_of_pixels</span> <span class="o">=</span> <span class="n">original_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">original_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Set of labels in the image</span>
    <span class="n">labels_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="c1"># Greyscale image</span>
    <span class="n">grey_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">original_image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">labels_set</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">region</span>

        <span class="c1"># Extract the color info of regions from the original image</span>
        <span class="n">extract_image</span> <span class="o">=</span> <span class="n">original_image</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">region_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">extract_image</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_of_pixels</span><span class="p">)</span>
        <span class="n">average_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">extract_image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">avg_colors_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">average_color</span><span class="p">)</span>

        <span class="c1"># Extract the brightness related info of regions from the greyscale image</span>
        <span class="n">extract_gray_image</span> <span class="o">=</span> <span class="n">grey_image</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">brightest_color_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">extract_gray_image</span><span class="p">)</span>
        <span class="n">brightest_color</span> <span class="o">=</span> <span class="n">extract_image</span><span class="p">[</span><span class="n">brightest_color_loc</span><span class="p">]</span>
        <span class="n">brightest_colors_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">brightest_color</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">avg_colors_list</span><span class="p">,</span> <span class="n">brightest_colors_list</span><span class="p">,</span> <span class="n">region_sizes</span></div>


<div class="viewcode-block" id="contrast_between_regions"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.contrast_between_regions">[docs]</a><span class="k">def</span> <span class="nf">contrast_between_regions</span><span class="p">(</span><span class="n">region_colors</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">region_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the contrast between the segmented regions in image using the color of regions</span>
<span class="sd">    and adjacency matrix</span>

<span class="sd">    :param region_colors: A list of colors of segmented regions</span>
<span class="sd">    :param matrix: A 2D adjacency matrix that describe the spatial relationship between the regions \</span>
<span class="sd">    Expect a binary matrix, where 1 means adjacent and 0 means non-adjacent</span>
<span class="sd">    :param region_weights: A 1D array of weights that can be applied onto the contrast calculate for each \</span>
<span class="sd">    regions. \</span>
<span class="sd">    e.g. Regions may have different sizes, and you can weight the computed contrast by the size of the \</span>
<span class="sd">    regions. Expected shape of the regions weight is shape==number of regions</span>
<span class="sd">    :return: A 2D numpy matrix where each entry is the contrast between the row indexed region and column \</span>
<span class="sd">    indexed region. Contrast ratio &gt;= 1, an entry with 0 means row indexed region and column indexed region \</span>
<span class="sd">    are non-adjacent</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Invalid shape of the adjacency matrix, the matrix must&quot;</span> \
                                               <span class="s2">&quot;be a 2D binary numpy array with a square shape. shape[0]&quot;</span> \
                                               <span class="s2">&quot;==shape[1]&quot;</span>
    <span class="k">assert</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">region_colors</span><span class="p">),</span> <span class="s2">&quot;Incompatible adjacency matrix with region_colors,&quot;</span> \
                                                  <span class="s2">&quot; different number of regions in matrix and region_colors&quot;</span> \
                                                  <span class="s2">&quot; list&quot;</span>
    <span class="c1"># List of row that contains the contrast between two regions</span>
    <span class="n">contrast_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># If no region weights are given, then use the uniform weights</span>
    <span class="k">if</span> <span class="n">region_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">region_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>

    <span class="c1"># Compute the contrast between each adjacent regions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
        <span class="n">contrast_row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># If two regions are adjacent</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Compute the contrast and append it to the list</span>
                <span class="n">contrast</span> <span class="o">=</span> <span class="n">contrast_ratio</span><span class="p">(</span><span class="n">region_colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">region_colors</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">region_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">contrast_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contrast</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Else append 0 as non-adjacent</span>
                <span class="n">contrast_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">contrast_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contrast_row</span><span class="p">)</span>
    <span class="n">contrast_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">contrast_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contrast_list</span></div>


<span class="k">def</span> <span class="nf">_RGB2sRGB</span><span class="p">(</span><span class="n">RGB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the 24-bits Adobe RGB color to the standard RGB color defined</span>
<span class="sd">    in Web Content Accessibility Guidelines (WCAG) 2.0</span>
<span class="sd">    see https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef for more references</span>

<span class="sd">    :param RGB: The input RGB color or colors shape== ... x 3 (R, G, and B channels)</span>
<span class="sd">    :return: converted sRGB colors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sRGB</span> <span class="o">=</span> <span class="n">RGB</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="k">return</span> <span class="n">sRGB</span>


<span class="k">def</span> <span class="nf">_sRGB2luminance</span><span class="p">(</span><span class="n">sRGB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute luminance of standard RGB color</span>
<span class="sd">    see https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef for more references</span>

<span class="sd">    :param sRGB: Input sRGB color or colors shape==... x 3 (sR, sG, and sB channels)</span>
<span class="sd">    :return: the luminance computed using the sRGB color</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lRGB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">sRGB</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">lRGB</span><span class="p">[</span><span class="n">sRGB</span> <span class="o">&lt;=</span> <span class="mf">0.03928</span><span class="p">]</span> <span class="o">=</span> <span class="n">sRGB</span><span class="p">[</span><span class="n">sRGB</span> <span class="o">&lt;=</span> <span class="mf">0.03928</span><span class="p">]</span> <span class="o">/</span> <span class="mf">12.92</span>
    <span class="n">lRGB</span><span class="p">[</span><span class="n">sRGB</span> <span class="o">&gt;</span> <span class="mf">0.03928</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">sRGB</span><span class="p">[</span><span class="n">sRGB</span> <span class="o">&gt;</span> <span class="mf">0.03928</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.055</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.055</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.4</span>
    <span class="n">luminance</span> <span class="o">=</span> <span class="mf">0.2126</span> <span class="o">*</span> <span class="n">lRGB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.7152</span> <span class="o">*</span> <span class="n">lRGB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.0722</span> <span class="o">*</span> <span class="n">lRGB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">luminance</span>


<div class="viewcode-block" id="contrast_ratio"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.contrast_ratio">[docs]</a><span class="k">def</span> <span class="nf">contrast_ratio</span><span class="p">(</span><span class="n">color1</span><span class="p">,</span> <span class="n">color2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the contrast ratio between two 24-bits RGB colors in range [0, 255]</span>
<span class="sd">    see https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef for more references</span>

<span class="sd">    :param color1: one of the 24-bits RGB colors in range [0, 255]</span>
<span class="sd">    :param color2: one of the 24-bits RGB colors in range [0, 255]</span>
<span class="sd">    :return: the contrast ratio between two 24-bits RGB colors. Contrast ratio &gt;= 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">luminance1</span> <span class="o">=</span> <span class="n">_sRGB2luminance</span><span class="p">(</span><span class="n">_RGB2sRGB</span><span class="p">(</span><span class="n">color1</span><span class="p">))</span>
    <span class="n">luminance2</span> <span class="o">=</span> <span class="n">_sRGB2luminance</span><span class="p">(</span><span class="n">_RGB2sRGB</span><span class="p">(</span><span class="n">color2</span><span class="p">))</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">luminance1</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">luminance2</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ratio</span>
    <span class="k">return</span> <span class="n">ratio</span></div>


<div class="viewcode-block" id="grabcut_foreback_segmentation"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.grabcut_foreback_segmentation">[docs]</a><span class="k">def</span> <span class="nf">grabcut_foreback_segmentation</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">start_row</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">row_size</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_size</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_iter</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the GrabCut segmentation over the input image with a rectangle of possible foreground</span>
<span class="sd">    specified by user. The GrabCut segment the image into two parts foreground and background, and</span>
<span class="sd">    the function return the 1D image of the foreground and background as the output</span>

<span class="sd">    :param image: The input image for GrabCut segmentation</span>
<span class="sd">    :param start_row: The starting row of the foreground rectangle of possible foreground</span>
<span class="sd">    :param start_col: The starting col of the foreground rectangle of possible foreground</span>
<span class="sd">    :param row_size: The vertical length of the rectangle</span>
<span class="sd">    :param col_size: The horizontal length of the rectangle</span>
<span class="sd">    :param num_iter: The number of iterations for GrabCut to run</span>
<span class="sd">    :return: 1D image of the foreground part of the image, and 1D image of the background part of the image \</span>
<span class="sd">    Expected shape== Number of pixels x channels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start_row</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">start_col</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">row_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">row_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">col_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">col_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">//</span> <span class="mi">3</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="c1"># Temporary array for background Gaussian mixture model</span>
    <span class="n">background_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">65</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c1"># Temporary array for foreground Gaussian mixture model</span>
    <span class="n">foreground_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">65</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c1"># Rectangle box for possible foreground</span>
    <span class="n">rectangle</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_col</span><span class="p">,</span> <span class="n">start_row</span><span class="p">,</span> <span class="n">col_size</span><span class="p">,</span> <span class="n">row_size</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">grabCut</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">rectangle</span><span class="p">,</span>
                <span class="n">background_model</span><span class="p">,</span> <span class="n">foreground_model</span><span class="p">,</span>
                <span class="n">num_iter</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GC_INIT_WITH_RECT</span><span class="p">)</span>
    <span class="c1"># The obvious foreground and probable foreground are marked with 1 and 3</span>
    <span class="n">foreground_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))]</span>
    <span class="c1"># The obvious background and probable background are marked with 0 and 2</span>
    <span class="n">background_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">foreground_image</span><span class="p">,</span> <span class="n">background_image</span></div>


<div class="viewcode-block" id="find_letter_box_from_videos"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.find_letter_box_from_videos">[docs]</a><span class="k">def</span> <span class="nf">find_letter_box_from_videos</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">num_sample</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the position of letterbox (black bars around the scene) in the input cv2 video object.</span>
<span class="sd">    The function samples out num_sample (20 by default) number of frames from cv2 video object, and find the position</span>
<span class="sd">    of letterbox in each frame. The function uses the median results from all sampled frames as the final position of</span>
<span class="sd">    video&#39;s letterbox.</span>

<span class="sd">    Notice that the function assumes the letterbox is black or very close to black.</span>

<span class="sd">    :param video: Input video object captured by cv2.VideoCapture()</span>
<span class="sd">    :param num_sample: Number of frames to sample from video for finding letterbox</span>
<span class="sd">    :return: The smaller row index of letterbox (bound for upper horizontal letterbox), \</span>
<span class="sd">             the larger row index of letterbox (bound for lower horizontal letterbox), \</span>
<span class="sd">             the smaller col index of letterbox (bound for left vertical letterbox), \</span>
<span class="sd">             and the larger col index of letterbox (bound for right vertical letterbox). \</span>
<span class="sd">             \</span>
<span class="sd">             The results are the median results on num_sample number of frames \</span>
<span class="sd">             \</span>
<span class="sd">             To extract the frame without letterbox from letterboxing frame, \</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">film_length_in_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">CAP_PROP_FRAME_COUNT</span><span class="p">))</span>

    <span class="c1"># Sampled out num_sample number of frames from input video</span>
    <span class="n">possible_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">film_length_in_frames</span> <span class="o">//</span> <span class="mi">6</span><span class="p">,</span> <span class="n">film_length_in_frames</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">//</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">frame_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">possible_indexes</span><span class="p">,</span> <span class="n">num_sample</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># list of possible smaller row indexes (bounding the upper letterbox)</span>
    <span class="n">possible_low_bound_ver</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list of possible larger row indexes (bounding the lower letterbox)</span>
    <span class="n">possible_high_bound_ver</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list of possible smaller column indexes (bounding the left letterbox)</span>
    <span class="n">possible_low_bound_hor</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list of possible larger column indexes (bounding the right letterbox)</span>
    <span class="n">possible_high_bound_hor</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Find the letterbox position on each sampled frame</span>
    <span class="k">for</span> <span class="n">frame_index</span> <span class="ow">in</span> <span class="n">frame_indexes</span><span class="p">:</span>
        <span class="n">video</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">CAP_PROP_POS_FRAMES</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">)</span>
        <span class="n">success</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">low_bound_v</span><span class="p">,</span> <span class="n">high_bound_v</span><span class="p">,</span> <span class="n">low_bound_h</span><span class="p">,</span> <span class="n">high_bound_h</span> <span class="o">=</span> <span class="n">get_letter_box_from_frames</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">possible_low_bound_ver</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">low_bound_v</span><span class="p">)</span>
            <span class="n">possible_high_bound_ver</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high_bound_v</span><span class="p">)</span>
            <span class="n">possible_low_bound_hor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">low_bound_h</span><span class="p">)</span>
            <span class="n">possible_high_bound_hor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high_bound_h</span><span class="p">)</span>

    <span class="c1"># Take the medians as final results</span>
    <span class="n">low_bound_ver</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">possible_low_bound_ver</span><span class="p">))</span>
    <span class="n">high_bound_ver</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">possible_high_bound_ver</span><span class="p">))</span>
    <span class="n">low_bound_hor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">possible_low_bound_hor</span><span class="p">))</span>
    <span class="n">high_bound_hor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">possible_high_bound_hor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">low_bound_ver</span><span class="p">,</span> <span class="n">high_bound_ver</span><span class="p">,</span> <span class="n">low_bound_hor</span><span class="p">,</span> <span class="n">high_bound_hor</span></div>


<div class="viewcode-block" id="get_letter_box_from_frames"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.get_letter_box_from_frames">[docs]</a><span class="k">def</span> <span class="nf">get_letter_box_from_frames</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the position of letterbox (black bars around the scene) in the input cv2 video object.</span>
<span class="sd">    The function assumes the letter box of the frame is black (dark)</span>

<span class="sd">    :param frame: Input frame</span>
<span class="sd">    :param threshold: The brightness threshold value that distinguish \</span>
<span class="sd">                      the region of interest (bright) and letterbox (dark)</span>
<span class="sd">    :return: The smaller row index of letterbox (bound for upper horizontal letterbox), \</span>
<span class="sd">             the larger row index of letterbox (bound for lower horizontal letterbox), \</span>
<span class="sd">             the smaller col index of letterbox (bound for left vertical letterbox), \</span>
<span class="sd">             and the larger col index of letterbox (bound for right vertical letterbox). \</span>
<span class="sd">             \</span>
<span class="sd">             To extract the frame without letterbox from letterboxing frame, \</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_bound_ver</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_bound_ver</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">low_bound_hor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_bound_hor</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">low_bound_ver</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">high_bound_ver</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">frame</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">low_bound_hor</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">frame</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">high_bound_hor</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">low_bound_ver</span><span class="p">,</span> <span class="n">high_bound_ver</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">low_bound_hor</span><span class="p">,</span> <span class="n">high_bound_hor</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="get_contrast_matrix_and_labeled_image"><a class="viewcode-back" href="../../../utils/artist.html#kalmus.utils.artist.get_contrast_matrix_and_labeled_image">[docs]</a><span class="k">def</span> <span class="nf">get_contrast_matrix_and_labeled_image</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">minimum_segment_size</span><span class="o">=</span><span class="mf">0.0004</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function that use the watershed method to segment the input image return the matrix of the</span>
<span class="sd">    brightness contrast of each segmented region with respect to its neighbors (adjacent segmented regions)</span>

<span class="sd">    :param frame: The input frame</span>
<span class="sd">    :param minimum_segment_size: The minimum size of the segmented region in the ratio to the whole frame. Range (0, 1)</span>
<span class="sd">    :return: The matrix with shape (num_regions x num_regions) whose cell [i, j] represents the contrast \</span>
<span class="sd">             between the region i and region j, and the corresponding labeled image (segmentation)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">grey_frame</span> <span class="o">=</span> <span class="n">watershed_segmentation</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">minimum_segment_size</span><span class="o">=</span><span class="n">minimum_segment_size</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">rag_to_matrix</span><span class="p">(</span><span class="n">get_rag</span><span class="p">(</span><span class="n">grey_frame</span><span class="p">,</span> <span class="n">labels</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
        <span class="n">avg_color</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">region_sizes</span> <span class="o">=</span> <span class="n">color_of_regions</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="n">contrast_matrix</span> <span class="o">=</span> <span class="n">contrast_between_regions</span><span class="p">(</span><span class="n">avg_color</span><span class="p">,</span> <span class="n">adjacency_matrix</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">contrast_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">contrast_matrix</span><span class="p">,</span> <span class="n">labels</span></div>


<span class="k">def</span> <span class="nf">write_in_info</span><span class="p">(</span><span class="n">info_row</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;output.csv&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write a row of information to the csv file with a python list (not numpy array).</span>
<span class="sd">    All the values in numpy array (such as colors) are recommended to be converted to the list</span>
<span class="sd">    before write into the info_row.</span>

<span class="sd">    :param mode: The mode for using the file</span>
<span class="sd">    :param info_row: A row of data that will be write to the target csv file</span>
<span class="sd">    :param file_name: The name of the csv file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>
        <span class="n">file_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">info_row</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Yida Chen, Eric Faden, and Nathan Ryan.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>